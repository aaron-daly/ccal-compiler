/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. CCALParser.jj */
/*@egen*//* CA4003 - ASSIGNMENT 1 - LEXICAL AND SYNTAX ANALYSER FOR THE CCAL LANGUAGE */

/*** STUDENT DETAILS ***
 Aaron Daly
 13376916
 aaron.daly42@mail.dcu.ie
************************/

/* I declare that this is my own work, and that I am aware of the consequences
   of plagerism in DCU. */

options {
  JAVA_UNICODE_ESCAPE = true;
  TOKEN_FACTORY = "Token";
  IGNORE_CASE = true;
  LOOKAHEAD = 1;
               
                 
}

PARSER_BEGIN(CCALParser)

  public class CCALParser/*@bgen(jjtree)*/implements CCALParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTCCALParserState jjtree = new JJTCCALParserState();

/*@egen*/
    public static void main(String [] args) {
      CCALParser parser;
      if (args.length == 0) {
        System.out.println("Reading from standard input...");
        parser = new CCALParser(System.in);
      } else if (args.length == 1) {
        try {
          parser = new CCALParser(new java.io.FileInputStream(args[0]));
        } catch (java.io.FileNotFoundException e) {
          System.out.printf("File '$s' not found.", args[0]);
          return;
        }
      } else {
        System.out.println("Invalid use of CCALParser. Either use system.in or specify a filename as an arguement.");
        return;
      }
      try {

        SimpleNode root = parser.Prog();
        root.dump(" ");

      } catch (ParseException e) {
        System.out.println(e.getMessage());
        System.out.println("CCALParser: Parsing was unsuccessful.");
      }
    }
  }

PARSER_END(CCALParser)

TOKEN_MGR_DECLS : {
  static int commentNesting;
}

// Tokens to skip
SKIP : {
" "
| "\n"
| "\t"
| "\r"
| "\f"
| <"//" (~["\n"])*> // Informal comments
| "/*" { commentNesting++; } : FORMAL_COMMENT
}

// Formal comments
<FORMAL_COMMENT> SKIP : {
  "/*" { commentNesting++; }
| "*/" { commentNesting--;
         if (commentNesting == 0) {
           SwitchTo(DEFAULT);
         }}
| <~[]>
}

// Reserved Words
TOKEN : {
  <VAR: "var">
| <CONST: "const">
| <RETURN: "return">
| <INTEGER: "integer">
| <BOOLEAN: "boolean">
| <VOID: "void">
| <MAIN: "main">
| <IF: "if">
| <ELSE: "else">
| <WHILE: "while">
| <SKIP_: "skip">
| <TRUE: "true">
| <FALSE: "false">
}

// Language Tokens
TOKEN : {
  <COMMA: ",">
  | <SEMIC: ";">
  | <COLON: ":">
  | <ASSIGN: "=">
  | <LBRACE: "{">
  | <RBRACE: "}">
  | <LPAREN: "(">
  | <RPAREN: ")">
  | <PLUS: "+">
  | <MINUS: "-">
  | <TILDE: "~">
  | <OR: "||">
  | <AND: "&&">
  | <EQUALS: "==">
  | <NOT_EQUALS: "!=">
  | <LESS_THAN: "<">
  | <LT_EQUALS: "<=">
  | <GREATER_THAN: ">">
  | <GT_EQUALS: ">=">
}

// Ints and Identifiers
TOKEN : {
  <INT: (<MINUS>)?["1"-"9"](<DIGIT>)* | "0">
| <IDENTIFIER: <LETTER>(<LETTER>|<DIGIT>|"_")*>
| <#DIGIT: ["0"-"9"]>
| <#LETTER: ["a"-"z", "A"-"Z"]>
}

SimpleNode Prog()       : {/*@bgen(jjtree) PROG */
  ASTPROG jjtn000 = new ASTPROG(JJTPROG);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PROG */
  try {
/*@egen*/
  declList() funcList() main() <EOF>/*@bgen(jjtree)*/
                                     {
                                       jjtree.closeNodeScope(jjtn000, true);
                                       jjtc000 = false;
                                     }
/*@egen*/ { return jjtn000; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void declList() : {/*@bgen(jjtree) declList */
  ASTdeclList jjtn000 = new ASTdeclList(JJTDECLLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) declList */
  try {
/*@egen*/
  (decl())*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void decl() : {/*@bgen(jjtree) decl */
  ASTdecl jjtn000 = new ASTdecl(JJTDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) decl */
  try {
/*@egen*/
  (varDecl()
  | constDecl())/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void varDecl()           : {/*@bgen(jjtree) VAR_DECL */
  ASTVAR_DECL jjtn000 = new ASTVAR_DECL(JJTVAR_DECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) VAR_DECL */
  try {
/*@egen*/
  <VAR> identifier() <COLON> type() <SEMIC>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void constDecl()             : {/*@bgen(jjtree) CONST_DECL */
  ASTCONST_DECL jjtn000 = new ASTCONST_DECL(JJTCONST_DECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) CONST_DECL */
  try {
/*@egen*/
  <CONST> identifier() <COLON> type() <ASSIGN> exp() <SEMIC>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void funcList() : {/*@bgen(jjtree) funcList */
  ASTfuncList jjtn000 = new ASTfuncList(JJTFUNCLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) funcList */
  try {
/*@egen*/
  (func())*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void func() : {/*@bgen(jjtree) func */
  ASTfunc jjtn000 = new ASTfunc(JJTFUNC);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) func */
  try {
/*@egen*/
  type() identifier() <LPAREN> paramList() <RPAREN>
   <LBRACE> declList() stmBlock() <RETURN> <LPAREN> (exp() | {}) <RPAREN> <SEMIC> <RBRACE>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void type() : {/*@bgen(jjtree) type */
               ASTtype jjtn000 = new ASTtype(JJTTYPE);
               boolean jjtc000 = true;
               jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) type */
  try {
/*@egen*/
  t = <INTEGER>/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/ { jjtn000.value = t.image; }
| t = <BOOLEAN>/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/ { jjtn000.value = t.image; }
| t = <VOID>/*@bgen(jjtree)*/
             {
               jjtree.closeNodeScope(jjtn000, true);
               jjtc000 = false;
             }
/*@egen*/ { jjtn000.value = t.image; }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void paramList() : {/*@bgen(jjtree) paramList */
  ASTparamList jjtn000 = new ASTparamList(JJTPARAMLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) paramList */
  try {
/*@egen*/
  param() (<COMMA> param())*
|/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/ {}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void param() : {/*@bgen(jjtree) param */
                ASTparam jjtn000 = new ASTparam(JJTPARAM);
                boolean jjtc000 = true;
                jjtree.openNodeScope(jjtn000);
/*@egen*/String name;}
{/*@bgen(jjtree) param */
  try {
/*@egen*/
  name = identifier() <COLON> type()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void main() : {/*@bgen(jjtree) main */
  ASTmain jjtn000 = new ASTmain(JJTMAIN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) main */
  try {
/*@egen*/
  <MAIN> <LBRACE> declList() stmBlock() <RBRACE>
  |/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/ {}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void stmBlock() : {/*@bgen(jjtree) stmBlock */
  ASTstmBlock jjtn000 = new ASTstmBlock(JJTSTMBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) stmBlock */
  try {
/*@egen*/
  stm() stmBlock()
|/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/ {}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void stm() : {/*@bgen(jjtree) stm */
  ASTstm jjtn000 = new ASTstm(JJTSTM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) stm */
  try {
/*@egen*/
  identifier() (<ASSIGN> exp() <SEMIC> | <LPAREN> argList() <RPAREN>)
| <LBRACE> stmBlock() <RBRACE>
| <IF> cond() <LBRACE> stmBlock() <RBRACE> <ELSE> <LBRACE> stmBlock() <RBRACE>
| <WHILE> cond() <LBRACE> stmBlock() <RBRACE>
| <SKIP_> <SEMIC>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void exp() : {/*@bgen(jjtree) exp */
  ASTexp jjtn000 = new ASTexp(JJTEXP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) exp */
  try {
/*@egen*/
  frag() recurExp()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void frag() : {/*@bgen(jjtree) frag */
  ASTfrag jjtn000 = new ASTfrag(JJTFRAG);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) frag */
  try {
/*@egen*/
  <LPAREN> exp() <RPAREN>
| identifier() (<LPAREN> argList() <RPAREN> |/*@bgen(jjtree)*/
                                              {
                                                jjtree.closeNodeScope(jjtn000, true);
                                                jjtc000 = false;
                                              }
/*@egen*/ {})
| <MINUS> identifier()
| <INT>
| <TRUE>
| <FALSE>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void recurExp() : {/*@bgen(jjtree) recurExp */
  ASTrecurExp jjtn000 = new ASTrecurExp(JJTRECUREXP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) recurExp */
  try {
/*@egen*/
  (binOp() exp()) recurExp()
|/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/ {}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void binOp() : {/*@bgen(jjtree) binOp */
                ASTbinOp jjtn000 = new ASTbinOp(JJTBINOP);
                boolean jjtc000 = true;
                jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) binOp */
  try {
/*@egen*/
  t = <PLUS>/*@bgen(jjtree)*/
             {
               jjtree.closeNodeScope(jjtn000, true);
               jjtc000 = false;
             }
/*@egen*/ { jjtn000.value = t.image; }
| t = <MINUS>/*@bgen(jjtree)*/
              {
                jjtree.closeNodeScope(jjtn000, true);
                jjtc000 = false;
              }
/*@egen*/ { jjtn000.value = t.image; }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void cond() : {/*@bgen(jjtree) cond */
  ASTcond jjtn000 = new ASTcond(JJTCOND);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) cond */
  try {
/*@egen*/
  simpleCond() recurCond()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void simpleCond() : {/*@bgen(jjtree) simpleCond */
  ASTsimpleCond jjtn000 = new ASTsimpleCond(JJTSIMPLECOND);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) simpleCond */
  try {
/*@egen*/
  <TILDE> cond()
| <LPAREN> cond() <RPAREN>
| exp() compOp() exp()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void recurCond() : {/*@bgen(jjtree) recurCond */
  ASTrecurCond jjtn000 = new ASTrecurCond(JJTRECURCOND);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) recurCond */
  try {
/*@egen*/
  (<OR> | <AND>) cond() recurCond() |/*@bgen(jjtree)*/
                                      {
                                        jjtree.closeNodeScope(jjtn000, true);
                                        jjtc000 = false;
                                      }
/*@egen*/ {}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void compOp() : {/*@bgen(jjtree) compOp */
                 ASTcompOp jjtn000 = new ASTcompOp(JJTCOMPOP);
                 boolean jjtc000 = true;
                 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) compOp */
  try {
/*@egen*/
  t = <EQUALS>/*@bgen(jjtree)*/
               {
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
               }
/*@egen*/ { jjtn000.value = t.image; }
| t = <NOT_EQUALS>/*@bgen(jjtree)*/
                   {
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                   }
/*@egen*/ { jjtn000.value = t.image; }
| t = <LESS_THAN>/*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                  }
/*@egen*/ { jjtn000.value = t.image; }
| t = <LT_EQUALS>/*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                  }
/*@egen*/ { jjtn000.value = t.image; }
| t = <GREATER_THAN>/*@bgen(jjtree)*/
                     {
                       jjtree.closeNodeScope(jjtn000, true);
                       jjtc000 = false;
                     }
/*@egen*/ { jjtn000.value = t.image; }
| t = <GT_EQUALS>/*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                  }
/*@egen*/ { jjtn000.value = t.image; }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void argList() : {/*@bgen(jjtree) argList */
  ASTargList jjtn000 = new ASTargList(JJTARGLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) argList */
  try {
/*@egen*/
  identifier() (<COMMA> identifier())*
|/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/ {}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

String identifier() : {/*@bgen(jjtree) identifier */
                       ASTidentifier jjtn000 = new ASTidentifier(JJTIDENTIFIER);
                       boolean jjtc000 = true;
                       jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) identifier */
  try {
/*@egen*/
  t = <IDENTIFIER>/*@bgen(jjtree)*/
                   {
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                   }
/*@egen*/ { jjtn000.value = t.image; return t.image; }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
